# use-form
[![CircleCI](https://circleci.com/gh/taystack/use-form.svg?style=shield)](https://circleci.com/gh/taystack/use-form)

[![npm downloads](https://img.shields.io/npm/dm/use-form.svg?style=flat-square)](https://www.npmjs.com/package/use-form)
[![gzip size](https://img.badgesize.io/https://unpkg.com/use-form?compression=gzip&amp;style=flat-square)](https://unpkg.com/use-form)
[![npm version](https://img.shields.io/npm/v/use-forms.svg?style=flat-square)](https://www.npmjs.com/package/use-form)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](http://makeapullrequest.com)

Use-form is a declarative typescript form control library. Use-form allows you to quickly apply setters/getters/validators within atomic, props-less components by following React's Context API.

This README was generated by [anansi](https://github.com/ntucker/anansi/tree/master/packages/generator-js#readme).

## Installation
```bash
yarn add @taystack/create-form
```

## Usage

This library employs the factory pattern when creating the data-layer for your form controls.
If you are familiar with `React.createContext` then you will be familiar with how to use this library.

### `createForm(options? = {})`
```typescript
import { createForm } from '@taystack/create-form';

type Login = {
  email: string;
  password: string;
  session: boolean;
}

const LoginForm = createForm<Login>()
// { Context, Provider }
```

### Options
#### `options.validate: Record<K = keyof T, (value: T[K], values: T) => string | undefined>`
Provide custom validation methods upon receiving changes to key `K` of provided type `T`.
The keys allowed in your `validate` option must match the keys you provided from type `T`,
but are not required.

For the `LoginForm` example, we can provide options to validate `email | password`:
```typescript
const options = {
  validate: {
    email: (value) => !value.length ? 'Email cannot be empty' : undefined,
    password: (value) => !value.length ? 'Password cannot be empty' : undefined,
  },
};
```

### `LoginForm.Provider`
This behaves like `React.createContext(...).Provider` such that access to `LoginForm` values can only be made from components within this provider.
```tsx
const LOGIN_DEFAULTS: Login = {
  email: '',
  password: '',
  session: false,
}
function LoginFormPage() {
  return (
    <LoginForm.Provider defaultValue={LOGIN_DEFAULTS}>
      ...
    </LoginForm.Provider>
  )
}
```

#### Provider prop `defaultValue: T`
Where `T extends Record<string, string | number | boolean>`. This library currently supports primitive values. `HTML` change events typically involve primitive values.

This will be the default values we use in our form as type `T`. In the example above, `T` is of type `Login`.

### `LoginForm.Context`
This behaves like `React.createContext(...)` such that access to the `LoginForm` APIs can be made.
```tsx
// Controlled inputs
function LoginFormEmailComponent() {
  const form = React.useContext(LoginForm.Context);
  return (
    <>
      <label htmlFor={form.name.email}>Email</label>
      <input
        id={form.name.email}
        name={form.name.email}
        value={form.values.email}
        onChange={(event) => form.set.email(event.target.value)}
      />
      {form.error.email && <div>{form.error.email}</div>}
    </>
  )
};
```

### `const form = useContext(MyForm.Context)`

|**attribute**|**type**|**effect**|
|---|---|---|
|`form.default`|`T`|Required, immutable default values provided by you within `<MyForm.Provider defaultValue={value} />`.|
|`form.current`|`T`|Current state of the form values.|
|`form.set[FIELD]()`|`Record<keyof T, (value: T[keyof T], values?: T) => string \| number \| boolean>`|Allows setting of `form.current` values for matching `form.current.[keyof T]`.|
|`form.error`|`Record<keyof T, string \| undefined>`|Custom validations will exist *if* you have the matching `options.validate[keyof T]` defined.|
|`form.name`|`Record<keyof T, string>`|Provides a unique value for use as a primary key for any given field.|
|`form.reset(key)`|`(key: keyof T) => void`|Reset `form.current` state to `Provider.props.defaultValue`. Clears any files, reader data, etc.|
|`form.getPayload()`|||
|`form.getFormData()`|`() => FormData`|Obtain `FormData` for use with http request/fetch `Content-Type: application/x-www-form-urlencoded`.|

## Example
The example above shows a controlled input situation. This is the default behavior. If you prefer to use uncontrolled inputs, ie: derive values from FormData when you `<form>` `onSubmit`, you can provide `uncontrolled` to the `createForm.options`. This will disable all state setter functionality, aside from validations:
```tsx
const LoginForm = createForm<Login>({
  validate: {
    email: (value) => value.length === 0 ? 'Cannot be empty' : undefined,
    password: (value) => value.length === 0 ? 'Cannot be empty' : undefined,
  }
})
```


## Development

With [Visual Studio Code](https://code.visualstudio.com), simply press `F5` to start the development server and browser.

#### Run dev:

```bash
yarn start
```

#### Build prod:

`Ctrl+shift+B` in [Visual Studio Code](https://code.visualstudio.com)

```bash
yarn build
```

#### Run prod: (after build)

```bash
yarn start:server
```

#### Analyze production bundle sizes:

```bash
yarn build:analyze
```

#### Run with [React Profiler](https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html):

```bash
yarn build:profile
```

#### Check Packages for duplicates or circular dependencies:

```bash
yarn pkgcheck
```


#### Run with [Storybook](https://storybook.js.org/):

```bash
yarn storybook
```


#### Share demo on Stackblitz

https://stackblitz.com/github/taystack/use-form
